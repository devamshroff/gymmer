module.exports=[92362,e=>e.a(async(t,r)=>{try{var n=e.i(54799),s=e.i(89171),o=e.i(12530),i=e.i(58574),a=e.i(68032),l=e.i(73852),u=t([o,i]);[o,i]=u.then?(await u)():u;let g=process.env.OPENAI_MODEL||"gpt-4o-mini";function c(e){return e.toLowerCase().replace(/[_-]+/g," ").replace(/[^a-z0-9 ]/g,"").replace(/\s+/g," ").trim()}function d(e){return(0,n.createHash)("sha256").update(JSON.stringify(e)).digest("hex")}async function p(e){let t=new Map,r=new Map;for(let n of e){let e=String(n.name||"").toLowerCase(),s=c(String(n.name||""));t.set(e,n.id),r.has(s)||r.set(s,n.id)}return{exactLower:t,normalized:r}}async function h(e,t,r){let n=String(t.name||"").trim(),s=n.toLowerCase(),o=c(n),u=e.exactLower.get(s);if(u)return{id:u,created:!1};let d=e.normalized.get(o);if(d)return{id:d,created:!1};let p=Number.isFinite(Number(t.timerSeconds))&&Number(t.timerSeconds)>0?Math.round(Number(t.timerSeconds)):null,h=(0,l.normalizeTypeList)(t.muscleGroups||t.stretchTypes,l.STRETCH_MUSCLE_TAGS),m=t.tips||null,g=p,f=h;if(!g||!m){let e=await (0,a.generateStretchInsights)({kind:"stretch",name:n,timerSeconds:g??void 0,muscleGroups:h.length?h:void 0,goalsText:r});m||(m=e?.tips??null),g||(g=e?.timerSeconds??null),0===f.length&&(f=(0,l.normalizeTypeList)(e?.muscleGroups,l.STRETCH_MUSCLE_TAGS))}if(!g)throw Error(`Missing timerSeconds for stretch "${n}"`);let R=f.length?f:["unknown"],w=await (0,i.createStretch)({name:n,timerSeconds:g,tips:m||void 0,muscleGroups:R});return e.exactLower.set(s,w),e.normalized.set(o,w),{id:w,created:!0}}async function m(e,{params:t}){let r=await (0,o.requireAuth)();if("error"in r)return r.error;let{user:n}=r;if(!process.env.OPENAI_API_KEY)return s.NextResponse.json({error:"Missing OPENAI_API_KEY"},{status:500});try{var a,l,u;let e,r,o,{id:c}=await t,m=Number(c);if(Number.isNaN(m))return s.NextResponse.json({error:"Invalid routine id"},{status:400});let f=await (0,i.getRoutineById)(m,n.id);if(!f)return s.NextResponse.json({error:"Routine not found"},{status:404});let R=await (0,i.getRoutineExercises)(m),w=R.flatMap(e=>e.exercise_id2&&e.exercise2_name?[`Superset: ${e.exercise_name} + ${e.exercise2_name}`]:[e.exercise_name]);if(0===w.length)return s.NextResponse.json({error:"No exercises found for routine"},{status:400});let x=await (0,i.getUserGoals)(n.id),v=R.map(e=>({exerciseId1:e.exercise_id1,exerciseId2:e.exercise_id2??null})),S=await (0,i.getStretchVersion)(),E=d({routineId:m,routineName:f.name||"",routineDescription:f.description??null,exercisePairs:v,goalsText:x??null,model:g,stretchVersion:S,signatureVersion:1}),N=await (0,i.getRoutineStretchRecommendationCache)({routineId:m,userId:n.id,signature:E});if(N)return s.NextResponse.json({recommendedPreIds:N.recommendedPreIds,recommendedPostIds:N.recommendedPostIds,createdStretches:[]});let y=await (0,i.getAllStretches)(),A=y.map(e=>e.name),C=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${process.env.OPENAI_API_KEY}`,"Content-Type":"application/json"},body:JSON.stringify({model:g,messages:[{role:"system",content:(a=f.name,l=f.description,u=R.length,r=x?`User goals: ${x}`:"User goals: (not provided)",['You are a gym trainer helping users make consistent progress.\nRecommend stretches for this workout.\nGiven the exercise list, provide pre-workout and post-workout stretches.\nEnsure every primary muscle used in the exercises has at least one stretch in pre-workout and one in post-workout.\nReturn ONLY valid JSON with this exact shape:\n{\n  "preWorkoutStretches": [ { "name": string, "timerSeconds": number, "tips": string (optional), "muscleGroups": string[] (optional) } ],\n  "postWorkoutStretches": [ { "name": string, "timerSeconds": number, "tips": string (optional), "muscleGroups": string[] (optional) } ]\n}\nReturn at least 4 stretches per list.\nIncrease stretch count with more exercises: 4-5 for <=4 exercises, 5-7 for 5-8, 7-9 for 9+.\nUse concise stretch names.',`Routine: ${a||"Workout routine"}`,l?`Description: ${l}`:"Description: (none)",`Exercise count: ${u??w.length}`,A?.length?`Available stretches: ${A.join(", ")}`:"Available stretches: (none)","Prefer existing stretches from the lists above when possible. If a needed stretch is missing, suggest a new one.",r,`Exercises: ${w.join(", ")}`].join("\n"))},{role:"user",content:"Recommend stretches for this routine."}],temperature:.4})});if(!C.ok){let e=await C.text();return s.NextResponse.json({error:`OpenAI request failed: ${e}`},{status:502})}let P=await C.json(),I=P.choices?.[0]?.message?.content?.trim();if(!I)return s.NextResponse.json({error:"No content returned from model"},{status:502});let _=(o=I.match(/```(?:json)?\s*([\s\S]*?)\s*```/i),o?.[1]?o[1]:I);try{e=JSON.parse(_)}catch(e){return s.NextResponse.json({error:"Model did not return valid JSON"},{status:502})}let T=Array.isArray(e.preWorkoutStretches)?e.preWorkoutStretches:[],O=Array.isArray(e.postWorkoutStretches)?e.postWorkoutStretches:[],b=R.length>=9?7:R.length>=5?5:4,k=await p(y),j=[],M=[],U=[];for(let e of T){if(!e?.name)continue;let t=await h(k,e,x);t.created&&j.push(t.id),M.push(t.id)}for(let e of O){if(!e?.name)continue;let t=await h(k,e,x);t.created&&j.push(t.id),U.push(t.id)}let H=e=>{if(e.length>=b)return e;let t=new Set(e),r=y.filter(e=>!t.has(e.id)).map(e=>e.id),n=b-e.length;return[...e,...r.slice(0,n)]},$=H(M),D=H(U),q=(await (0,i.getAllStretches)()).filter(e=>j.includes(e.id)),L=j.length>0?await (0,i.getStretchVersion)():S,G=d({routineId:m,routineName:f.name||"",routineDescription:f.description??null,exercisePairs:v,goalsText:x??null,model:g,stretchVersion:L,signatureVersion:1});return await (0,i.upsertRoutineStretchRecommendationCache)({routineId:m,userId:n.id,signature:G,recommendedPreIds:$,recommendedPostIds:D}),s.NextResponse.json({recommendedPreIds:$,recommendedPostIds:D,createdStretches:q})}catch(e){return console.error("Error generating stretch recommendations:",e),s.NextResponse.json({error:e.message||"Failed to generate recommendations"},{status:500})}}e.s(["POST",()=>m]),r()}catch(e){r(e)}},!1),51029,e=>e.a(async(t,r)=>{try{var n=e.i(47909),s=e.i(74017),o=e.i(96250),i=e.i(59756),a=e.i(61916),l=e.i(74677),u=e.i(69741),c=e.i(16795),d=e.i(87718),p=e.i(95169),h=e.i(47587),m=e.i(66012),g=e.i(70101),f=e.i(26937),R=e.i(10372),w=e.i(93695);e.i(52474);var x=e.i(220),v=e.i(92362),S=t([v]);[v]=S.then?(await S)():S;let y=new n.AppRouteRouteModule({definition:{kind:s.RouteKind.APP_ROUTE,page:"/api/routines/[id]/stretch-recommendations/route",pathname:"/api/routines/[id]/stretch-recommendations",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/routines/[id]/stretch-recommendations/route.ts",nextConfigOutput:"",userland:v}),{workAsyncStorage:A,workUnitAsyncStorage:C,serverHooks:P}=y;function E(){return(0,o.patchFetch)({workAsyncStorage:A,workUnitAsyncStorage:C})}async function N(e,t,r){y.isDev&&(0,i.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let n="/api/routines/[id]/stretch-recommendations/route";n=n.replace(/\/index$/,"")||"/";let o=await y.prepare(e,t,{srcPage:n,multiZoneDraftMode:!1});if(!o)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:v,params:S,nextConfig:E,parsedUrl:N,isDraftMode:A,prerenderManifest:C,routerServerContext:P,isOnDemandRevalidate:I,revalidateOnlyGenerated:_,resolvedPathname:T,clientReferenceManifest:O,serverActionsManifest:b}=o,k=(0,u.normalizeAppPath)(n),j=!!(C.dynamicRoutes[k]||C.routes[T]),M=async()=>((null==P?void 0:P.render404)?await P.render404(e,t,N,!1):t.end("This page could not be found"),null);if(j&&!A){let e=!!C.routes[T],t=C.dynamicRoutes[k];if(t&&!1===t.fallback&&!e){if(E.experimental.adapterPath)return await M();throw new w.NoFallbackError}}let U=null;!j||y.isDev||A||(U=T,U="/index"===U?"/":U);let H=!0===y.isDev||!j,$=j&&!H;b&&O&&(0,l.setManifestsSingleton)({page:n,clientReferenceManifest:O,serverActionsManifest:b});let D=e.method||"GET",q=(0,a.getTracer)(),L=q.getActiveScopeSpan(),G={params:S,prerenderManifest:C,renderOpts:{experimental:{authInterrupts:!!E.experimental.authInterrupts},cacheComponents:!!E.cacheComponents,supportsDynamicResponse:H,incrementalCache:(0,i.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:E.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,n,s)=>y.onRequestError(e,t,n,s,P)},sharedContext:{buildId:v}},K=new c.NodeNextRequest(e),F=new c.NodeNextResponse(t),W=d.NextRequestAdapter.fromNodeNextRequest(K,(0,d.signalFromNodeResponse)(t));try{let o=async e=>y.handle(W,G).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=q.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==p.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let s=r.get("next.route");if(s){let t=`${D} ${s}`;e.setAttributes({"next.route":s,"http.route":s,"next.span_name":t}),e.updateName(t)}else e.updateName(`${D} ${n}`)}),l=!!(0,i.getRequestMeta)(e,"minimalMode"),u=async i=>{var a,u;let c=async({previousCacheEntry:s})=>{try{if(!l&&I&&_&&!s)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await o(i);e.fetchMetrics=G.renderOpts.fetchMetrics;let a=G.renderOpts.pendingWaitUntil;a&&r.waitUntil&&(r.waitUntil(a),a=void 0);let u=G.renderOpts.collectedTags;if(!j)return await (0,m.sendResponse)(K,F,n,G.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,g.toNodeOutgoingHttpHeaders)(n.headers);u&&(t[R.NEXT_CACHE_TAGS_HEADER]=u),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==G.renderOpts.collectedRevalidate&&!(G.renderOpts.collectedRevalidate>=R.INFINITE_CACHE)&&G.renderOpts.collectedRevalidate,s=void 0===G.renderOpts.collectedExpire||G.renderOpts.collectedExpire>=R.INFINITE_CACHE?void 0:G.renderOpts.collectedExpire;return{value:{kind:x.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:s}}}}catch(t){throw(null==s?void 0:s.isStale)&&await y.onRequestError(e,t,{routerKind:"App Router",routePath:n,routeType:"route",revalidateReason:(0,h.getRevalidateReason)({isStaticGeneration:$,isOnDemandRevalidate:I})},!1,P),t}},d=await y.handleResponse({req:e,nextConfig:E,cacheKey:U,routeKind:s.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:C,isRoutePPREnabled:!1,isOnDemandRevalidate:I,revalidateOnlyGenerated:_,responseGenerator:c,waitUntil:r.waitUntil,isMinimalMode:l});if(!j)return null;if((null==d||null==(a=d.value)?void 0:a.kind)!==x.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==d||null==(u=d.value)?void 0:u.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});l||t.setHeader("x-nextjs-cache",I?"REVALIDATED":d.isMiss?"MISS":d.isStale?"STALE":"HIT"),A&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let p=(0,g.fromNodeOutgoingHttpHeaders)(d.value.headers);return l&&j||p.delete(R.NEXT_CACHE_TAGS_HEADER),!d.cacheControl||t.getHeader("Cache-Control")||p.get("Cache-Control")||p.set("Cache-Control",(0,f.getCacheControlHeader)(d.cacheControl)),await (0,m.sendResponse)(K,F,new Response(d.value.body,{headers:p,status:d.value.status||200})),null};L?await u(L):await q.withPropagatedContext(e.headers,()=>q.trace(p.BaseServerSpan.handleRequest,{spanName:`${D} ${n}`,kind:a.SpanKind.SERVER,attributes:{"http.method":D,"http.target":e.url}},u))}catch(t){if(t instanceof w.NoFallbackError||await y.onRequestError(e,t,{routerKind:"App Router",routePath:k,routeType:"route",revalidateReason:(0,h.getRevalidateReason)({isStaticGeneration:$,isOnDemandRevalidate:I})},!1,P),j)throw t;return await (0,m.sendResponse)(K,F,new Response(null,{status:500})),null}}e.s(["handler",()=>N,"patchFetch",()=>E,"routeModule",()=>y,"serverHooks",()=>P,"workAsyncStorage",()=>A,"workUnitAsyncStorage",()=>C]),r()}catch(e){r(e)}},!1)];

//# sourceMappingURL=_8dabe3cd._.js.map