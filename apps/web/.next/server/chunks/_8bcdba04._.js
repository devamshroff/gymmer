module.exports=[52900,e=>{"use strict";var t=e.i(22378);function r(e,a=t.SESSION_MODES.progress){return e===t.SESSION_MODES.progress||e===t.SESSION_MODES.maintenance||e===t.SESSION_MODES.light?e:a}e.s(["resolveSessionMode",()=>r])},85926,e=>e.a(async(t,r)=>{try{var a=e.i(89171),n=e.i(12530),s=e.i(58574),o=e.i(52900),i=e.i(22378),l=t([n,s]);[n,s]=l.then?(await l)():l;let c=process.env.OPENAI_MODEL||"gpt-4o-mini";function u(e){let t=null,r=null;for(let a of e)Number.isFinite(a.weight)&&(t=null===t?a.weight:Math.max(t,a.weight)),Number.isFinite(a.reps)&&(r=null===r?a.reps:Math.max(r,a.reps));return{maxWeight:t,maxReps:r}}function d(e){if("string"!=typeof e)return null;let t=e.trim();return t.length>0?t:null}async function p(e){let t=await (0,n.requireAuth)();if("error"in t)return t.error;let{user:r}=t;if(!process.env.OPENAI_API_KEY)return a.NextResponse.json({error:"Missing OPENAI_API_KEY"},{status:500});try{let t=await e.json(),n=Array.isArray(t?.exercises)?t.exercises:[];if(0===n.length)return a.NextResponse.json({error:"exercises are required"},{status:400});let l=(0,o.resolveSessionMode)(t?.sessionMode),p="string"==typeof t?.workoutName?t.workoutName:"",h=await (0,s.getUserGoals)(r.id),g=p?await (0,s.getLatestWorkoutReportForWorkoutName)(r.id,p):null,m=new Set,R=new Map;for(let e of n)if(e?.name){m.add(String(e.name));let t=e.primaryMetric??(e.isBodyweight?i.EXERCISE_PRIMARY_METRICS.repsOnly:i.EXERCISE_PRIMARY_METRICS.weight);R.set(String(e.name),t)}let f={};for(let e of m){let t=await (0,s.getRecentExerciseLogs)(e,r.id,4);f[e]=t.map(e=>{let t=[];for(let r=1;r<=4;r+=1){let a=e[`set${r}_weight`],n=e[`set${r}_reps`];null!==a&&null!==n&&t.push({weight:a,reps:n})}return{completedAt:e.completed_at||e.created_at,matchedRole:e.matched_role,warmup:null!==e.warmup_weight&&null!==e.warmup_reps?{weight:e.warmup_weight,reps:e.warmup_reps}:null,sets:t}})}let w={workoutName:p,sessionMode:l,goals:h||"",lastWorkoutReport:g||"",exercises:n,history:f,historySummary:function(e){let t={};for(let[r,a]of Object.entries(e)){let e=a[0]?u(a[0].sets):{maxWeight:null,maxReps:null},n=a[1]?u(a[1].sets):{maxWeight:null,maxReps:null};t[r]={latestMaxWeight:e.maxWeight,previousMaxWeight:n.maxWeight,latestMaxReps:e.maxReps,previousMaxReps:n.maxReps}}return t}(f)},E=new Map;for(let e of n){if(!e.isMachine||(e.primaryMetric??(e.isBodyweight?i.EXERCISE_PRIMARY_METRICS.repsOnly:i.EXERCISE_PRIMARY_METRICS.weight))!==i.EXERCISE_PRIMARY_METRICS.weight)continue;let t=(f[e.name]||[]).some(e=>e.sets.some(e=>e.weight>0));E.set(e.name,t)}let y=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${process.env.OPENAI_API_KEY}`,"Content-Type":"application/json"},body:JSON.stringify({model:c,messages:[{role:"system",content:'You are a gym trainer helping users make consistent progress. Use the workout goals, sessionMode, and recent history to suggest today\'s targets. If provided, use lastWorkoutReport from the prior session for this workout to guide targets. Provide an encouragement and recap trend changes using historySummary. Avoid form tips or stretching reminders; those are handled per exercise. User is able to pick between 3 modes based on how they are feeling today - Progress, Maintenance, and Light. Obviously if its the first time user is doing a particular exercise create a reasonable target based on the information you have. For progress, keep targets go up in targets a little unless slight adjustment helps recovery. Be mindful of their goals and push them for things that are more their goals. For maintenance, keep targets at baseline (last max) unless if doing multiple exercises with that muscle then maybe slight adjustment could help recovery. Take a call. For light sessions, reduce intensity a little bit and do not increase weight or reps. Some exercises are machine-based; their weight values represent added plates only. If no added-weight history exists, suggest reps only and leave suggestedWeight null. Each exercise has a primaryMetric and metricUnit; suggestedWeight should be the value for that metric (weight/height/time/distance) in the same units as the history. Return JSON only: {"encouragement":"...","goalSummary":"...","trendSummary":"...","targets":[{"name":"...","suggestedWeight":number|null,"suggestedReps":number|null,"rationale":"..."}]} Only include exercises provided by name.'},{role:"user",content:JSON.stringify(w)}],temperature:.3,max_tokens:1e3})});if(!y.ok){let e=await y.text();return a.NextResponse.json({error:`OpenAI request failed: ${e}`},{status:502})}let S=await y.json();S?.usage&&console.info("Workout targets token usage:",S.usage);let x=S.choices?.[0]?.message?.content;if(!x)return a.NextResponse.json({error:"No content returned from model"},{status:502});let v=null;try{let e;v=JSON.parse((e=x.match(/```(?:json)?\s*([\s\S]*?)\s*```/i),e?.[1]?e[1]:x))}catch(e){return a.NextResponse.json({error:"Failed to parse model response"},{status:502})}let N=function(e,t,r,a){if(!e||!Array.isArray(e.targets))return null;let n=[];for(let s of e.targets){if(!s||"string"!=typeof s.name||!t.has(s.name))continue;let e=Number(s.suggestedWeight),o=Number(s.suggestedReps),l=Number.isFinite(e)?e:null,u=Number.isFinite(o)?o:null;a.get(s.name)===i.EXERCISE_PRIMARY_METRICS.weight&&!1===r.get(s.name)&&(l=null),n.push({name:s.name,suggestedWeight:l,suggestedReps:u,rationale:"string"==typeof s.rationale?s.rationale:null})}return 0===n.length?null:{targets:n,encouragement:d(e.encouragement),goalSummary:d(e.goalSummary),trendSummary:d(e.trendSummary)}}(v,m,E,R);if(!N)return a.NextResponse.json({error:"Invalid target response"},{status:502});return a.NextResponse.json(N)}catch(e){return console.error("Error generating workout targets:",e),a.NextResponse.json({error:e.message||"Failed to generate targets"},{status:500})}}e.s(["POST",()=>p]),r()}catch(e){r(e)}},!1),8059,e=>e.a(async(t,r)=>{try{var a=e.i(47909),n=e.i(74017),s=e.i(96250),o=e.i(59756),i=e.i(61916),l=e.i(74677),u=e.i(69741),d=e.i(16795),p=e.i(87718),c=e.i(95169),h=e.i(47587),g=e.i(66012),m=e.i(70101),R=e.i(26937),f=e.i(10372),w=e.i(93695);e.i(52474);var E=e.i(220),y=e.i(85926),S=t([y]);[y]=S.then?(await S)():S;let N=new a.AppRouteRouteModule({definition:{kind:n.RouteKind.APP_ROUTE,page:"/api/workout-targets/route",pathname:"/api/workout-targets",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/workout-targets/route.ts",nextConfigOutput:"",userland:y}),{workAsyncStorage:_,workUnitAsyncStorage:A,serverHooks:C}=N;function x(){return(0,s.patchFetch)({workAsyncStorage:_,workUnitAsyncStorage:A})}async function v(e,t,r){N.isDev&&(0,o.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let a="/api/workout-targets/route";a=a.replace(/\/index$/,"")||"/";let s=await N.prepare(e,t,{srcPage:a,multiZoneDraftMode:!1});if(!s)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:y,params:S,nextConfig:x,parsedUrl:v,isDraftMode:_,prerenderManifest:A,routerServerContext:C,isOnDemandRevalidate:I,revalidateOnlyGenerated:M,resolvedPathname:O,clientReferenceManifest:b,serverActionsManifest:P}=s,k=(0,u.normalizeAppPath)(a),T=!!(A.dynamicRoutes[k]||A.routes[O]),j=async()=>((null==C?void 0:C.render404)?await C.render404(e,t,v,!1):t.end("This page could not be found"),null);if(T&&!_){let e=!!A.routes[O],t=A.dynamicRoutes[k];if(t&&!1===t.fallback&&!e){if(x.experimental.adapterPath)return await j();throw new w.NoFallbackError}}let U=null;!T||N.isDev||_||(U=O,U="/index"===U?"/":U);let D=!0===N.isDev||!T,F=T&&!D;P&&b&&(0,l.setManifestsSingleton)({page:a,clientReferenceManifest:b,serverActionsManifest:P});let q=e.method||"GET",H=(0,i.getTracer)(),W=H.getActiveScopeSpan(),$={params:S,prerenderManifest:A,renderOpts:{experimental:{authInterrupts:!!x.experimental.authInterrupts},cacheComponents:!!x.cacheComponents,supportsDynamicResponse:D,incrementalCache:(0,o.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:x.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,a,n)=>N.onRequestError(e,t,a,n,C)},sharedContext:{buildId:y}},K=new d.NodeNextRequest(e),Y=new d.NodeNextResponse(t),B=p.NextRequestAdapter.fromNodeNextRequest(K,(0,p.signalFromNodeResponse)(t));try{let s=async e=>N.handle(B,$).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=H.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==c.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let n=r.get("next.route");if(n){let t=`${q} ${n}`;e.setAttributes({"next.route":n,"http.route":n,"next.span_name":t}),e.updateName(t)}else e.updateName(`${q} ${a}`)}),l=!!(0,o.getRequestMeta)(e,"minimalMode"),u=async o=>{var i,u;let d=async({previousCacheEntry:n})=>{try{if(!l&&I&&M&&!n)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let a=await s(o);e.fetchMetrics=$.renderOpts.fetchMetrics;let i=$.renderOpts.pendingWaitUntil;i&&r.waitUntil&&(r.waitUntil(i),i=void 0);let u=$.renderOpts.collectedTags;if(!T)return await (0,g.sendResponse)(K,Y,a,$.renderOpts.pendingWaitUntil),null;{let e=await a.blob(),t=(0,m.toNodeOutgoingHttpHeaders)(a.headers);u&&(t[f.NEXT_CACHE_TAGS_HEADER]=u),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==$.renderOpts.collectedRevalidate&&!($.renderOpts.collectedRevalidate>=f.INFINITE_CACHE)&&$.renderOpts.collectedRevalidate,n=void 0===$.renderOpts.collectedExpire||$.renderOpts.collectedExpire>=f.INFINITE_CACHE?void 0:$.renderOpts.collectedExpire;return{value:{kind:E.CachedRouteKind.APP_ROUTE,status:a.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:n}}}}catch(t){throw(null==n?void 0:n.isStale)&&await N.onRequestError(e,t,{routerKind:"App Router",routePath:a,routeType:"route",revalidateReason:(0,h.getRevalidateReason)({isStaticGeneration:F,isOnDemandRevalidate:I})},!1,C),t}},p=await N.handleResponse({req:e,nextConfig:x,cacheKey:U,routeKind:n.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:A,isRoutePPREnabled:!1,isOnDemandRevalidate:I,revalidateOnlyGenerated:M,responseGenerator:d,waitUntil:r.waitUntil,isMinimalMode:l});if(!T)return null;if((null==p||null==(i=p.value)?void 0:i.kind)!==E.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==p||null==(u=p.value)?void 0:u.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});l||t.setHeader("x-nextjs-cache",I?"REVALIDATED":p.isMiss?"MISS":p.isStale?"STALE":"HIT"),_&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let c=(0,m.fromNodeOutgoingHttpHeaders)(p.value.headers);return l&&T||c.delete(f.NEXT_CACHE_TAGS_HEADER),!p.cacheControl||t.getHeader("Cache-Control")||c.get("Cache-Control")||c.set("Cache-Control",(0,R.getCacheControlHeader)(p.cacheControl)),await (0,g.sendResponse)(K,Y,new Response(p.value.body,{headers:c,status:p.value.status||200})),null};W?await u(W):await H.withPropagatedContext(e.headers,()=>H.trace(c.BaseServerSpan.handleRequest,{spanName:`${q} ${a}`,kind:i.SpanKind.SERVER,attributes:{"http.method":q,"http.target":e.url}},u))}catch(t){if(t instanceof w.NoFallbackError||await N.onRequestError(e,t,{routerKind:"App Router",routePath:k,routeType:"route",revalidateReason:(0,h.getRevalidateReason)({isStaticGeneration:F,isOnDemandRevalidate:I})},!1,C),T)throw t;return await (0,g.sendResponse)(K,Y,new Response(null,{status:500})),null}}e.s(["handler",()=>v,"patchFetch",()=>x,"routeModule",()=>N,"serverHooks",()=>C,"workAsyncStorage",()=>_,"workUnitAsyncStorage",()=>A]),r()}catch(e){r(e)}},!1)];

//# sourceMappingURL=_8bcdba04._.js.map